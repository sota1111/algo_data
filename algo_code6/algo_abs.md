# 6章 二分探索法
二分探索法：「探索範囲を半減させていくことによって解を求める手法」
## 6.1 配列の二分探索
本節では、「ソート済み配列の中から目的のものを高速に探索するアルゴリズム」という文脈で二分探索法を解説する。  
サイズN=8、ソート済み配列a={3,5,8,10,14,17,21,39}にkey=9が含まれているかを考える。  
keyと配列の中心の値を比較し、比較結果に応じて以下の処理を行う。
* key = 中心の値 → 探索を終了
* key < 中心の値 → 配列の左半分を残す
* key > 中心の値 → 配列の右半分を残す
## 6.2 「配列の二分探索」の計算量
ステップごとに配列サイズが半減するので、2^k<=N<2^k+1  
つまり計算量は、O(logN)
## 6.2 C++のstd::lower_bound()
C++のstd::lower_bound()の仕様：ソート済み配列aにおいて、a[i]>=keyという条件を満たす最小の添字iを返す。以下を得ることが可能。
* 配列aの中に値keyがなくても、key以上の値の範囲での最小値がわかる。
* 配列aの中に値keyが複数あったとき、そのうちの最小の添字がわかる。
## 6.3 一般化した二分探索法
一般化した二分探索法：各整数xについてtrue/falseの２値で判定される条件Pが与えられて、ある整数l,r(l＜r)が存在して、以下が成立しているとする。
* P(l) = false
* P(r) = true
* ある整数M(l＜M≦r)が存在して、x＜Mなるxに対してP(x)=falseであり、
x≧Mなるxに対してP(x)=trueである
このときD=r-lとして、二分探索法はMをO(logD)の計算量で求めることができる。
➡プログラムのl行目からr行目との間にバグがあることがわかっているとき、バグの発生した範囲を二分探索的に特定する作業と同様。